<!DOCTYPE html>
<html lang="en" data-theme="light"><head>
    <title>docker · HZW</title>
    <meta charset="utf-8">
    
    <meta name="generator" content="Hugo 0.124.1">
    <meta property="og:title" content="docker" />
<meta property="og:description" content="a note for learning docker" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://seconsorl.github.io/post/docker/" /><meta property="og:image" content="https://seconsorl.github.io/images/profile.png" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2024-05-06T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-05-06T00:00:00+00:00" /><meta property="og:site_name" content="A junior from NBU" />



    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
    <meta name="description" content="HZW">
    
    
    
    <link rel="stylesheet" type="text/css" href="https://seconsorl.github.io/css/style.min.565d8c479597aa43658922d4b31e286529a7525a22c9546fa1018fc5e5ef6d86.css" integrity="sha256-Vl2MR5WXqkNliSLUsx4oZSmnUloiyVRvoQGPxeXvbYY=" crossorigin="anonymous" type="text/css">

    
    
    
    <script type="text/javascript" src="https://seconsorl.github.io/js/heyo-header.min.a3fa728a9f57833a31dfb45c48caaf1e4890c8c97f07bd7133fc2359745edb5d.js" integrity="sha256-o/pyip9Xgzox37RcSMqvHkiQyMl/B71xM/wjWXRe210=" crossorigin="anonymous"></script>

    
    
    <link rel="stylesheet" type="text/css" href="https://seconsorl.github.io/css/fonts.9398921f2d404983c2b7f9a68ddc72e3f5e58a3e38b0a8e4a70d75c12ebfb7c5.css" integrity="sha256-k5iSHy1ASYPCt/mmjdxy4/Xlij44sKjkpw11wS6/t8U=" crossorigin="anonymous">

    
    
    
    <script type="text/javascript" src="https://seconsorl.github.io/js/sidebar-toc.min.788b639e2ec681549740b90b3b865d5f9e1789e3ca9c06ccc45d65655434c954.js" integrity="sha256-eItjni7GgVSXQLkLO4ZdX54XiePKnAbMxF1lZVQ0yVQ=" crossorigin="anonymous"></script>

    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.1.9/p5.min.js" defer></script>

        
        
        <script type="text/javascript" src="https://seconsorl.github.io/js/sketch-graph.26b92ed9317bdc6f35642d588bdf3283f40998846e01cf4bee22a126907fbf3b.js" integrity="sha256-Jrku2TF73G81ZC1Yi98yg/QJmIRuAc9L7iKhJpB/vzs=" crossorigin="anonymous" defer></script>

        
        
        <script type="text/javascript" src="https://seconsorl.github.io/js/sketch-digitalRain.af8a7b5c4428cc62d5bf49bf2698d4112c2459ee0c22c1c753ab304aef69888a.js" integrity="sha256-r4p7XEQozGLVv0m/JpjUESwkWe4MIsHHU6swSu9piIo=" crossorigin="anonymous" defer></script>

        
        
        <script type="text/javascript" src="https://seconsorl.github.io/js/sketch-circleBrushStrokes.fe8fc3ee52e1d90e9236be8c36a27711efa024beb4da304829f95dfbb61d6e84.js" integrity="sha256-/o/D7lLh2Q6SNr6MNqJ3Ee&#43;gJL602jBIKfld&#43;7YdboQ=" crossorigin="anonymous" defer></script>

        
        
        <script type="text/javascript" src="https://seconsorl.github.io/js/sketch-meta.71b5202ea881c86ac19e4b55414656a5444204a4ba08ff7368a5aa99c0a60949.js" integrity="sha256-cbUgLqiByGrBnktVQUZWpURCBKS6CP9zaKWqmcCmCUk=" crossorigin="anonymous" defer></script>

        
        
        <script type="text/javascript" src="https://seconsorl.github.io/js/sidebar-sketch.min.2e95015880993ef9abcad62d111decea22406616931bce193254bf8af2339953.js" integrity="sha256-LpUBWICZPvmrytYtER3s6iJAZhaTG84ZMlS/ivIzmVM=" crossorigin="anonymous" defer></script>
    
    
    
    <link rel="shortcut icon" href="https://seconsorl.github.io/favicons/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="180x180" href="https://seconsorl.github.io/favicons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://seconsorl.github.io/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://seconsorl.github.io/favicons/favicon-16x16.png">
    <link rel="canonical" href="https://seconsorl.github.io/post/docker/">
    
    
    
    
    

    
    <meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://seconsorl.github.io/images/profile.png" /><meta name="twitter:title" content="docker"/>
<meta name="twitter:description" content="a note for learning docker"/>

</head><body>
        <div class="main">
            <div class="page-top">
    <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false" >
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
      </a>
    <ul class="nav" id="navMenu">
        
        
            
            <li><a  href="/"  title="">Home</a></li>
        
            
            <li><a  href="/post/"  title="">Posts</a></li>
        
            
            <li><a  href="/about/"  title="">About</a></li>
        
        <li class="grow"></li>
        
        <li>
            <a class="theme-switch" title="Switch Theme">
                <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>
            <div class="sidebar" id="sidebar">
    <div class="top-toc">
        <img src="https://seconsorl.github.io/images/profile.png" alt="profile picture">
        
        <a href="/">A junior from NBU</a>
    </div>
    
    <div class="middle-sidebar grow" id="middle-sidebar">
        
            
            
                
            

            
        
    </div>

    <div class="footer">
        <ul class="social-links">
            
            <li>
                <a href="https://linkedin.com/" target="_blank" rel="noopener noreferrer" rel="me" aria-label="Linkedin">
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
            
            <li>
                <a href="https://github.com/SeConSorL" target="_blank" rel="noopener noreferrer" rel="me" aria-label="GitHub">
                    <i class="fab fa-github" aria-hidden="true"></i>
                </a>
            </li>
            
            <li>
                <a href="https://www.instagram.com/" target="_blank" rel="noopener noreferrer" rel="me" aria-label="instagram">
                    <i class="fab fa-instagram" aria-hidden="true"></i>
                </a>
            </li>
            
            <li>
                <a href="mailto:216002917@nbu.edu.cn" target="_blank" rel="noopener noreferrer" rel="me" aria-label="e-mail">
                    <i class="fas fa-envelope" aria-hidden="true"></i>
                </a>
            </li>
            
        </ul>

        <div class="by">by HZW <b>·</b> 2024</div>
    </div>
</div>
            <div class="content">
<div class="post">
    
    <div class="thumbnail" style="box-shadow: var(--box-shadow); height: 350px;">
        <img src=https://seconsorl.github.io/images/docker.png style="object-position: 50% 70%;" title=Docker alt=Docker loading="lazy">
    </div>
    
    <div class="post-title">
        <h1>docker</h1>
        
            <div class="post-header">
    <div style="padding-top: 10px;">
        <i class="far fa-calendar"></i><span class="date">May 6, 2024</span>
        <i class="far fa-clock"></i><span class="reading-time">3 minutes</span>
        


    </div>
</div>
        
    </div>
    <div class="post-content">
        <h2 id="tip">TIP</h2>
<p>安装<a href="https://zhuanlan.zhihu.com/p/617103690">DOMJudge</a></p>
<p><a href="https://www.runoob.com/docker/docker-tutorial.html">菜鸟教程</a></p>
<p><a href="https://blog.csdn.net/m0_61503020/article/details/125456520">CSDN</a></p>
<p><a href="https://www.docker.com/">Docker 官网</a>    <a href="https://www.docker.org.cn/">docker中文库</a></p>
<p><a href="https://github.com/docker/docker-ce">Github Docker 源码</a></p>
<h2 id="介绍">介绍</h2>
<p><strong>Docker</strong>，翻译过来就是码头工人</p>
<p>Docker 是dotCloud公司开源的一个基于<strong>LXC（Linux Container）<strong>的高级容器引擎，基于</strong>Go 语言</strong>并遵从 Apache2.0 协议开源。</p>
<blockquote>
<p>Linux Container 容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源，而且不需要提供指令解释机制以及全虚拟化的其他复杂性。LXC主要通过<strong>Kernel的namespace</strong>实现每个用户实例之间的项目隔离，通过cgroup实现对资源的配额和调度。</p>
</blockquote>
<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>容器是完全使用<strong>沙箱机制</strong>，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。<strong>不依赖于任何语言、框架或者包装系统</strong></p>
<p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版）</p>
<p><img alt="docker" src="https://www.runoob.com/wp-content/uploads/2016/04/docker01.png"></p>
<h4 id="docker容器技术与虚拟机的区别">Docker容器技术与虚拟机的区别</h4>
<p><strong>相同点</strong>：docker和容器技术和虚拟机技术，都是虚拟化技术。</p>
<p><strong>不同点</strong>：docker有着比虚拟机<strong>更少的抽象层</strong>。 由于<strong>docker不需要Hypervisor实现硬件资源虚拟化</strong>，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。所以<strong>docker效率比虚拟机效率高。达到了秒级启动的地步</strong>。</p>
<p><strong>docker相较于VM的优点：</strong></p>
<p>1、比VM小、快，Docker容器的尺寸减小相比于整个虚拟机大大简化了分布到云和分发时间的开销。Docker启动一个容器实例时间仅仅需要几秒钟。</p>
<p>2、Docker是一个开放的平台，构建、发布和运行分布式应用程序。</p>
<p>3、开发人员不需要关系具体是哪个Linux操作系统</p>
<p>4、Google、微软（azure）、亚马逊、IBM等都支持docker。</p>
<p>5、Docker支持Unix/Linux操作系统，也支持Windows和Mac。</p>
<p><strong>Docker局限性：</strong></p>
<p>Docker用于应用程序时是最有用的，但并不包含数据。日志、数据库等通常放在Docker容器外。一个容器的镜像通常都很小，不用和存储大量数据，存储可以通过外部挂载等方式使用，比如：NFS、ipsan、MFS等 ，或者docker命令 ，-v映射磁盘分区。</p>
<p>总之，docker只用于计算，存储交给别人。</p>
<p><img alt="docker架构图" src="https://img-blog.csdnimg.cn/5ac27867aa3544e5b40f30b4d27f5e5a.png#pic_center"></p>
<h4 id="工作流程">工作流程</h4>
<p>1、启动docker</p>
<p>2、下载镜像到本地</p>
<p>3、启动docker容器实例</p>
<blockquote>
<p>（注册一个dockerhub）</p>
</blockquote>
<p>==Docker核心技术:==
1、<strong>Namespace</strong> —&gt; 实现Container的进程、网络、消息、文件系统和主机名的隔离。
2、<strong>Cgroup</strong> —&gt; 实现对资源的配额和调度。</p>
<blockquote>
<p>注意：Cgroup的配额，可以指定实例使用的CPU个数，内存大小等。</p>
</blockquote>
<h4 id="docker的应用场景">Docker的应用场景</h4>
<ul>
<li>Web 应用的自动化打包和发布。</li>
<li>自动化测试和持续集成、发布。</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用。</li>
<li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li>
</ul>
<h4 id="特点">特点</h4>
<ul>
<li>文件系统隔离：每个进程容器运行在一个完全独立的根文件系统里。</li>
<li>资源隔离：系统资源，像CPU和内存等可以分配到不同的容器中，使用cgroup。</li>
<li>网络隔离：每个进程容器运行在自己的网路空间，虚拟接口和IP地址。</li>
<li>日志记录：Docker将收集到和记录的每个进程容器的标准流（stdout/stderr/stdin），用于实时检索或者批量检索</li>
<li>变更管理：容器文件系统的变更可以提交到新的镜像中，并可重复使用以创建更多的容器。无需使用模板或者手动配置。</li>
<li>交互式shell：Docker可以分配一个虚拟终端并且关联到任何容器的标准输出上，例如运行一个一次性交互shell。</li>
</ul>
<h4 id="优点">优点</h4>
<p>Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 能够将应用程序与基础架构分开，从而可以快速交付软件。</p>
<p>借助 Docker，可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，大大减少编写代码和在生产环境中运行代码之间的延迟。</p>
<p><strong>1、快速，一致地交付您的应用程序</strong></p>
<p>Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。</p>
<p><strong>2、响应式部署和扩展</strong></p>
<p>Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。</p>
<p>Docker 的可移植性和轻量级的特性，可以轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。</p>
<p><strong>3、在同一硬件上运行更多工作负载</strong></p>
<p>Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。</p>
<h2 id="安装ubuntu">安装（Ubuntu）</h2>
<p><a href="https://docs.docker.com/engine/install/ubuntu/">Ubuntu安装Docker官方文档</a></p>
<p>Docker最早的版本名是docker和docker-engin，现在的名字是docker-ce和docker-ee。</p>
<p>2017年初，docker公司将原先的docker开源项目改名为<strong>moby</strong>。<strong>moby</strong>是集成了原先的docker项目，是社区维护的开源项目，谁都可以在moby的基础打造自己的容器产品。</p>
<p><strong>docker-ce</strong> 是docker公司维护的开源项目，是一个基于moby项目的免费容器产品。</p>
<blockquote>
<p>注：moby是源代码，docker-ce 和docker-ee 是产品容器，rpm包。</p>
</blockquote>
<h3 id="yum安装">yum安装</h3>
<p><strong>安装docker依赖环境。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum install -y yum-utils device-mapper-persistent-data lvm2
</span></span></code></pre></div><p><strong>配置国内docker-ce的yum源（这里采用的是阿里云）</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># yum-config-manager命令作用是添加yum源。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># 配置成功。</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">cd</span> /etc/yum.repos.d
</span></span><span style="display:flex;"><span>ls
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#有docker-ce.repo就代表配置成功</span>
</span></span></code></pre></div><p><strong>安装docker</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum -y install docker-ce doker-ce-cli containerd.io
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#如果不知道包名的作用，可以使用yum info 程序 命令查看</span>
</span></span></code></pre></div><p><strong>开启网络转发功能</strong></p>
<p>默认会自动开启。</p>
<p>路径 ：<code>/proc/sys/net/ipv4/ip_forward</code></p>
<p>手动开启：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vim /etc/sysctl.conf   <span style="color:#6272a4">#插入以下内容</span>
</span></span><span style="display:flex;"><span>net.ipv4.forward <span style="color:#ff79c6">=</span><span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sysctl -p   <span style="color:#6272a4">#生效</span>
</span></span><span style="display:flex;"><span>cat /proc/sys/net/ipv4/ip_forward  <span style="color:#6272a4">#查看结果，为1开启成功。</span>
</span></span></code></pre></div><p><strong>关闭防火墙</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>iptables -nL <span style="color:#6272a4">#查看一下iptable规则，关闭防火墙后会自动插入新规则</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>systemctl stop firewalld <span style="color:#ff79c6">&amp;&amp;</span> systemctl disable firewalld  <span style="color:#6272a4">#关闭防火墙</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sysctlrem restart docker <span style="color:#6272a4"># 关闭防火墙要把docker重启一下，不然docker的ip包转发功能无法使用。即便防火墙关闭了，docker依旧会调用内核模块netfilter增加规则，所以会新增iptables规则</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>iptables -nL <span style="color:#6272a4">#再查看一下iptable规则，会发现多出很多规则  TARGET里有DOCKER</span>
</span></span></code></pre></div><p><strong>启动服务</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>systemctl start docker <span style="color:#ff79c6">&amp;&amp;</span> systemctl <span style="color:#8be9fd;font-style:italic">enable</span> docker
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#启动完后 这里ip转发会自动变成1。默认0</span>
</span></span><span style="display:flex;"><span>cat /proc/sys/net/ipv4/ip_forward  <span style="color:#6272a4">#查看结果，为1开启成功。</span>
</span></span></code></pre></div><p>查看docker版本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker version <span style="color:#6272a4">#安装完后查看docker版本</span>
</span></span></code></pre></div><p>这里可以看到docker是一个C/S架构的模式。客户端是我们的命令行操作，服务端是一个守护进程。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker info  <span style="color:#6272a4">#查看docker基本信息</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#docker root dir 是 docker镜像的地址</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#registry 是 docker仓库的地址</span>
</span></span></code></pre></div><p>我们可以通过<code>docker info</code>看到机器存放docker镜像的地址，也可以看到docker仓库的地址。</p>
<h3 id="使用官方安装脚本自动安装">使用官方安装脚本自动安装</h3>
<p>安装命令如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span> curl -fsSL https://test.docker.com -o test-docker.sh
</span></span><span style="display:flex;"><span> sudo sh test-docker.sh
</span></span></code></pre></div><h3 id="手动安装">手动安装</h3>
<h4 id="卸载旧版本">卸载旧版本</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ sudo apt-get remove docker docker-engine docker.io containerd runc
</span></span></code></pre></div><h4 id="安装-docker-engine-community">安装 Docker Engine-Community</h4>
<p><strong>使用 Docker 仓库进行安装</strong></p>
<p>在新主机上首次安装 Docker Engine-Community 之前，需要设置 Docker 仓库。之后，您可以从仓库安装和更新 Docker 。</p>
<p><strong>设置仓库</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#6272a4"># 更新 apt 包索引。</span>
</span></span><span style="display:flex;"><span>$ sudo apt-get update
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#安装 apt 依赖包，用于通过HTTPS来获取仓库:</span>
</span></span><span style="display:flex;"><span>$ sudo apt-get install <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    apt-transport-https <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    ca-certificates <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    curl <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    gnupg-agent <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    software-properties-common
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#添加 Docker 的官方 GPG 密钥：</span>
</span></span><span style="display:flex;"><span>$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
</span></span></code></pre></div><h2 id="docker平台的基本使用方法">Docker平台的基本使用方法。</h2>
<h4 id="帮助命令">帮助命令</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker version     <span style="color:#6272a4">#显示docker详细信息</span>
</span></span><span style="display:flex;"><span>docker info       <span style="color:#6272a4">#显示docker的系统信息，包括镜像和容器的数量</span>
</span></span><span style="display:flex;"><span>docker --help     <span style="color:#6272a4">#docker帮助命令手册</span>
</span></span></code></pre></div><h4 id="镜像命令">镜像命令</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker images  <span style="color:#6272a4">#查看所有本地主机的镜像</span>
</span></span><span style="display:flex;"><span>docker search 镜像名           <span style="color:#6272a4">#搜索镜像</span>
</span></span><span style="display:flex;"><span>docker pull 镜像名 <span style="color:#ff79c6">[</span>标签<span style="color:#ff79c6">]</span>      <span style="color:#6272a4">#下载镜像（如果不写tag，默认是latest）</span>
</span></span><span style="display:flex;"><span>docker rmi 镜像名 <span style="color:#ff79c6">[</span>标签<span style="color:#ff79c6">]</span>       <span style="color:#6272a4">#删除镜像    docker rmi -f $(docker images -aq)  删除全部镜像</span>
</span></span><span style="display:flex;"><span>docker tag  镜像名:版本   新镜像名:版本    <span style="color:#6272a4">#复制镜像并且修改名称</span>
</span></span><span style="display:flex;"><span>docker commit  -a <span style="color:#f1fa8c">&#34;xxx&#34;</span>  -c <span style="color:#f1fa8c">&#34;xxx&#34;</span> 镜像ID 名字：版本   <span style="color:#6272a4">#提交镜像 </span>
</span></span><span style="display:flex;"><span>-a :提交的镜像作者；
</span></span><span style="display:flex;"><span>-c :使用Dockerfile指令来创建镜像；
</span></span><span style="display:flex;"><span>-m :提交时的说明文字；
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>docker load -i    /xxx/xxx.tar         <span style="color:#6272a4">#导入镜像</span>
</span></span><span style="display:flex;"><span>docker save -o   /xxx/xxx.tar          <span style="color:#6272a4">#保存一个镜像为一个tar包</span>
</span></span></code></pre></div><h4 id="容器命令">容器命令</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker run <span style="color:#ff79c6">[</span>可选参数<span style="color:#ff79c6">]</span> image 命令 <span style="color:#6272a4">#启动容器（无镜像会先下载镜像）</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#参数说明</span>
</span></span><span style="display:flex;"><span>--name <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;Name&#34;</span>   容器名字
</span></span><span style="display:flex;"><span>-c   后面跟待完成的命令
</span></span><span style="display:flex;"><span>-d   以后台方式运行并且返回ID，启动守护进程式容器
</span></span><span style="display:flex;"><span>-i   使用交互方式运行容器，通常与t同时使用
</span></span><span style="display:flex;"><span>-t   为容器重新分配一个伪输入终端。也即启动交互式容器
</span></span><span style="display:flex;"><span>-p   指定容器端口    -p 容器端口:物理机端口  映射端口
</span></span><span style="display:flex;"><span>-P   随机指定端口
</span></span><span style="display:flex;"><span>-v   给容器挂载存储卷
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>docker build  <span style="color:#6272a4">#创建镜像        -f：指定dockerfile文件路径   -t：镜像名字以及标签</span>
</span></span><span style="display:flex;"><span>docker logs 容器实例的ID          <span style="color:#6272a4">#查看容器日志</span>
</span></span><span style="display:flex;"><span>docker rename 旧名字  新名字      <span style="color:#6272a4"># 给容器重新命名</span>
</span></span><span style="display:flex;"><span>docker top    容器实例的ID                  <span style="color:#6272a4">#查看容器内进程</span>
</span></span><span style="display:flex;"><span>docker ps -a                    <span style="color:#6272a4">#列出所有容器（不加-a就是在运行的）</span>
</span></span><span style="display:flex;"><span>docker rm      容器实例的ID                 <span style="color:#6272a4">#删除容器（正在运行容器不能删除，除非加-f选项）</span>
</span></span><span style="display:flex;"><span>docker <span style="color:#8be9fd;font-style:italic">kill</span>  容器实例的ID        <span style="color:#6272a4">#杀掉容器</span>
</span></span><span style="display:flex;"><span>docker <span style="color:#8be9fd;font-style:italic">history</span>   容器实例的ID    <span style="color:#6272a4">#查看docker镜像的变更历史</span>
</span></span><span style="display:flex;"><span>docker start 容器实例的ID        <span style="color:#6272a4">#启动容器</span>
</span></span><span style="display:flex;"><span>docker restart 容器实例的ID       <span style="color:#6272a4">#重启容器</span>
</span></span><span style="display:flex;"><span>docker stop 容器实例的ID         <span style="color:#6272a4">#停止正在运行的容器</span>
</span></span><span style="display:flex;"><span>docker attach /docker <span style="color:#8be9fd;font-style:italic">exec</span>  容器实例的ID   <span style="color:#6272a4">#同为进入容器命令，不同的是attach连接终止会让容器退出后台运行，而exec不会。并且，docker attach是进入正在执行的终端，不会情动新的进程，而docker exec则会开启一个新的终端，可以在里面操作。</span>
</span></span><span style="display:flex;"><span>docker image inspect  容器名称：容器标签       <span style="color:#6272a4">#查看容器内源数据</span>
</span></span><span style="display:flex;"><span>docker cp  容器id：容器内路径   目的主机路径           <span style="color:#6272a4">#从容器内拷贝文件到主机（常用）或者从主机拷贝到容器（一般用挂载）</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">exit</span>                           <span style="color:#6272a4">#直接退出容器 </span>
</span></span><span style="display:flex;"><span>crlt + P + Q                   <span style="color:#6272a4">#退出容器但是不终止运行</span>
</span></span></code></pre></div><h2 id="镜像">镜像</h2>
<h3 id="原理">原理</h3>
<h4 id="镜像是什么">镜像是什么？</h4>
<p>镜像是一种轻量级的、可执行的<strong>独立软件包</strong>。用来<strong>打包软件运行环境和基于运行环境的开发软件</strong>，它包含运行某个软件所需要的内容，包括代码、运行时、库、环境变量和配置文件。</p>
<h4 id="docker镜像加载原理">Docker镜像加载原理</h4>
<p><strong>UnionFS（联合文件系统）</strong></p>
<p>UnionFS（联合文件系统）：UnionFS文件系统是一种分层、轻量级并且高性能的文件系统。它支持对文件系统的修改作为一次提交来一层一层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。<strong>Union文件系统是Docker镜像的基础</strong>。镜像可以通过分层来进行继承，基于基础镜像，可以制作各种各样的应用镜像。</p>
<p>特性：一次同时加载多个文件系统，但是从外面开起来，只能看一个文件系统，联合加载会把各层文件系统叠加起来，最终的文件系统会包含所有的底层文件和目录。</p>
<p><strong>Docker镜像加载原理</strong></p>
<p>docker的镜像实际上是由一层一层的文件系统组成，这种层级关系就叫<strong>UnionFS</strong>。</p>
<p><strong>bootfs</strong>（boot file system）主要包括bootloader和kernel。</p>
<p>bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就在内存中了，此时内存的使用权由bootfs转交给内核，此时系统会卸载bootfs。</p>
<p><strong>rootfs</strong>（root file system），在bootfs之上。包含的就是典型Linux系统的/dev, /proc, /bin, /etc等等标准文件。rootfs就是各种不同的操作系统发行版本，比如Ubuntu、CentOS等。</p>
<blockquote>
<p>对于一个精简的OS，rootfs可以很小，只需要包含最基本的命令、工具和程序即可，因为底层直接用Host的kernel，自己只需要提供rootfs即可。由此可见不同的Linux发行版本，<strong>bootfs基本上是一致的</strong>，rootfs会有差别，所以<strong>不同的发行版可以公用bootfs</strong>，这也是一个镜像仅有几百MB的原因。</p>
</blockquote>
<h4 id="分层理解">分层理解</h4>
<p>举例，用<code>docker pull nginx</code>命令可以看到下载的文件的形式是一层一层的。</p>
<p>**docker为什么会使用这种方法呢？**最大的好处，就是==资源共享==。比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需要在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有容器提供服务了，而且镜像的每一层都可以被共享。</p>
<p>通过<code>docker image inspect ngixn:latest</code>查看一下。会看到<strong>RootFS</strong>的<strong>layers</strong>中有多层。</p>
<p>所有的docker镜像都起始于一个基础镜像层，当进行修改或者增加新的内容时，就会在当前镜像层之上，创建新的镜像层。假如基于Ubuntu Linux 16.04创建一个新的镜像，这就是新镜像的<strong>第一层</strong>；如果在该镜像中添加Python包，就会在基础镜像之上创建<strong>第二个镜像层</strong>；如果继续添加安全补丁，就会创建<strong>第三个镜像层</strong>。</p>
<p>在添加额外的镜像的同时，<strong>镜像始终是当前所有镜像的组合</strong>。==docker镜像都是<strong>只读</strong>的，当容器启动时，一个新的可写层被加载到镜像的顶部。这一层就是我们所说的容器层，容器之下都叫镜像层。==</p>
<h4 id="提交镜像">提交镜像</h4>
<h5 id="命令">命令</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker commit 提交容器成为一个新的副本
</span></span><span style="display:flex;"><span>docker commit -m<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#34;提交的描述信息&#34;</span>  -a<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#34;作者&#34;</span>  容器id  目标镜像名:<span style="color:#ff79c6">[</span>TAG<span style="color:#ff79c6">]</span>
</span></span></code></pre></div><h5 id="实验">实验</h5>
<p>1、拉取一个tomcat镜像</p>
<p>2、启动tomcat。<code>docker run -itd -p 8080:8080 tomcat:latest /bin/bash</code></p>
<p>3、然后进入此容器<code>docker exec -it [容器ID] /bin/bash</code></p>
<p>4、默认tomcat镜像的webapp网页文件里是没有东西的，要从webapps.dist中把它拷贝出来。在<code>/usr/local/tomcat/</code> 中执行 <code>cp -r webapps.dist/* webapps</code></p>
<p>5、打开8080端口，在浏览器访问tomcat docker</p>
<p>6、提交镜像。<code>docker commit -a=“This my create tomcat” -m=“add webapps app” 81 tomcat02:1.0</code></p>
<p>查看<code>docker images</code>就可以看到制作的镜像</p>
<h3 id="简单镜像命令">简单镜像命令</h3>
<h4 id="搜索镜像docker-search"><strong>搜索镜像（docker search）</strong></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker search centos <span style="color:#6272a4">#从docker hub中搜索docker名为centos的镜像</span>
</span></span></code></pre></div><ul>
<li><strong>name</strong>:代表此镜像的名称</li>
<li><strong>description</strong>：此镜像的描述</li>
<li><strong>stars</strong>：下载次数</li>
<li><strong>official</strong>：是否由官方提供（官方提供可放心下载，可以基于此镜像做自己的镜像）</li>
</ul>
<h4 id="拉取镜像docker-pull"><strong>拉取镜像（docker pull）</strong></h4>
<p>默认是拉去docker hub上搜索到的最新版本（第一个）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker pull centos  <span style="color:#6272a4">#拉去名为centos的最新的镜像</span>
</span></span></code></pre></div><p>==如果TLS handshake timeout，配置镜像加速==</p>
<p>使用<a href="https://cr.console.aliyun.com">阿里云docker镜像加速器</a>的控制台，使用支付宝账号登录，左侧加速器帮助页面会为显示<strong>独立的加速地址</strong>，这个加速地址每个人的都不同。</p>
<p><strong>可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器。把自己的专属加速地址放到下面的地址改一下，写入文件就可以了。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#6272a4">#文件中的修改内容</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f1fa8c">&#34;registry-mirrors&#34;</span>: <span style="color:#ff79c6">[</span><span style="color:#f1fa8c">&#34;https://eu5rxjvf.mirror.aliyuncs.com&#34;</span><span style="color:#ff79c6">]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>systemctl daemon-reload  <span style="color:#6272a4">#启动配置</span>
</span></span><span style="display:flex;"><span>systemctl restart docker  <span style="color:#6272a4">#重启docker服务</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#docker info查看一下是否新增了阿里云的地址，在Registry Mirrors中会有地址</span>
</span></span></code></pre></div><h4 id="查看镜像docker-images">查看镜像（docker images）</h4>
<p>拉去之后使用<code>docker images</code>查看已下载镜像。</p>
<h4 id="使用u盘和网络下载方式导入镜像">使用U盘和网络下载方式导入镜像</h4>
<p>把docker-centos-httpd.tar镜像上传到linux上，就需要用到<code>docker load -i</code> 命令</p>
<p><code>docker load -i /root/docker-centos-httpd.tar</code></p>
<blockquote>
<p>docker镜像相当于对程序+程序依赖的库直接打包</p>
</blockquote>
<p>还有直接下载其他站点镜像的方法，命令如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker pull hub.c.163.com/library/&lt;registry&gt;:latest
</span></span></code></pre></div><h2 id="实战部署nginx">实战（部署Nginx）</h2>

    </div>
    <div class="post-footer">
        <div class="info">
            
            <span class="separator"><a class="tag" href="/tags/computer/">computer</a><a class="tag" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器</a></span>
        </div>
        


    </div>
    
        
    
</div>

                <div class="grow"></div>
                <div class="built-with">
    Built with <a href="https://gohugo.io/">Hugo</a> <b>·</b> Using the <a href="https://github.com/LucasVadilho/heyo-hugo-theme">heyo</a> theme
</div>
            </div>
        </div>
        
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/all.min.css" integrity="sha512-3M00D/rn8n+2ZVXBO9Hib0GKNpkm8MSUU/e2VNthDyBYxKWG+BftNYYcuEjXlyrSO637tidzMBXfE7sQm0INUg==" crossorigin="anonymous" referrerpolicy="no-referrer" />

<script type="text/javascript">
            
            
            window.MathJax = {
                tex: {
                    inlineMath: [['$', '$'], ['\\(', '\\)']],
                    displayMath: [['$$','$$'], ['\\[', '\\]']]
                },
                svg: {
                    scale: 1.25,
                }
            };
        </script><script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.0/es5/tex-mml-svg.min.js" integrity="sha512-/mL9Gs6E5Bz6NtPOr9eY&#43;T8IIdJbo2JL3TudApzFFelwBXEc3TeFLU6kPq122TJROv7jkktuBRkz5h8vGzrsyA==" crossorigin="anonymous"></script>
    </body>
</html>